let ie;var V,Pe;(typeof navigator>"u"||!((Pe=(V=navigator.userAgent)==null?void 0:V.startsWith)!=null&&Pe.call(V,"Mozilla/5.0 ")))&&(ie="oauth4webapi/v2.17.0");function R(t,e){if(t==null)return!1;try{return t instanceof e||Object.getPrototypeOf(t)[Symbol.toStringTag]===e.prototype[Symbol.toStringTag]}catch{return!1}}const X=Symbol(),Ne=Symbol(),L=Symbol(),Re=Symbol(),q=Symbol(),x=Symbol(),oe=Symbol(),se=new TextEncoder,Ie=new TextDecoder;function v(t){return typeof t=="string"?se.encode(t):Ie.decode(t)}const pe=32768;function Ke(t){t instanceof ArrayBuffer&&(t=new Uint8Array(t));const e=[];for(let n=0;n<t.byteLength;n+=pe)e.push(String.fromCharCode.apply(null,t.subarray(n,n+pe)));return btoa(e.join("")).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")}function $e(t){try{const e=atob(t.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"")),n=new Uint8Array(e.length);for(let r=0;r<e.length;r++)n[r]=e.charCodeAt(r);return n}catch(e){throw new s("The input to be decoded is not correctly encoded.",{cause:e})}}function g(t){return typeof t=="string"?$e(t):Ke(t)}class qe{constructor(e){this.cache=new Map,this._cache=new Map,this.maxSize=e}get(e){let n=this.cache.get(e);if(n)return n;if(n=this._cache.get(e))return this.update(e,n),n}has(e){return this.cache.has(e)||this._cache.has(e)}set(e,n){return this.cache.has(e)?this.cache.set(e,n):this.update(e,n),this}delete(e){return this.cache.has(e)?this.cache.delete(e):this._cache.has(e)?this._cache.delete(e):!1}update(e,n){this.cache.set(e,n),this.cache.size>=this.maxSize&&(this._cache=this.cache,this.cache=new Map)}}class m extends Error{constructor(e){var n;super(e??"operation not supported"),this.name=this.constructor.name,(n=Error.captureStackTrace)==null||n.call(Error,this,this.constructor)}}class Me extends Error{constructor(e,n){var r;super(e,n),this.name=this.constructor.name,(r=Error.captureStackTrace)==null||r.call(Error,this,this.constructor)}}const s=Me,Ee=new qe(100);function Ae(t){return t instanceof CryptoKey}function ce(t){return Ae(t)&&t.type==="private"}function Ge(t){return Ae(t)&&t.type==="public"}const ue=["PS256","ES256","RS256","PS384","ES384","RS384","PS512","ES512","RS512","EdDSA"];function ee(t){try{const e=t.headers.get("dpop-nonce");e&&Ee.set(new URL(t.url).origin,e)}catch{}return t}function Fe(t){return t.toLowerCase().replace(/^application\//,"")}function S(t){return!(t===null||typeof t!="object"||Array.isArray(t))}function j(t){R(t,Headers)&&(t=Object.fromEntries(t.entries()));const e=new Headers(t);if(ie&&!e.has("user-agent")&&e.set("user-agent",ie),e.has("authorization"))throw new TypeError('"options.headers" must not include the "authorization" header name');if(e.has("dpop"))throw new TypeError('"options.headers" must not include the "dpop" header name');return e}function te(t){if(typeof t=="function"&&(t=t()),!(t instanceof AbortSignal))throw new TypeError('"options.signal" must return or be an instance of AbortSignal');return t}async function Rt(t,e){if(!(t instanceof URL))throw new TypeError('"issuerIdentifier" must be an instance of URL');if(t.protocol!=="https:"&&t.protocol!=="http:")throw new TypeError('"issuer.protocol" must be "https:" or "http:"');const n=new URL(t.href);switch(e==null?void 0:e.algorithm){case void 0:case"oidc":n.pathname=`${n.pathname}/.well-known/openid-configuration`.replace("//","/");break;case"oauth2":n.pathname==="/"?n.pathname=".well-known/oauth-authorization-server":n.pathname=`.well-known/oauth-authorization-server/${n.pathname}`.replace("//","/");break;default:throw new TypeError('"options.algorithm" must be "oidc" (default), or "oauth2"')}const r=j(e==null?void 0:e.headers);return r.set("accept","application/json"),((e==null?void 0:e[L])||fetch)(n.href,{headers:Object.fromEntries(r.entries()),method:"GET",redirect:"manual",signal:e!=null&&e.signal?te(e.signal):null}).then(ee)}function f(t){return typeof t=="string"&&t.length!==0}async function Et(t,e){if(!(t instanceof URL))throw new TypeError('"expectedIssuer" must be an instance of URL');if(!R(e,Response))throw new TypeError('"response" must be an instance of Response');if(e.status!==200)throw new s('"response" is not a conform Authorization Server Metadata response');E(e);let n;try{n=await e.json()}catch(r){throw new s('failed to parse "response" body as JSON',{cause:r})}if(!S(n))throw new s('"response" body must be a top level object');if(!f(n.issuer))throw new s('"response" body "issuer" property must be a non-empty string');if(new URL(n.issuer).href!==t.href)throw new s('"response" body "issuer" does not match "expectedIssuer"');return n}function W(){return g(crypto.getRandomValues(new Uint8Array(32)))}function At(){return W()}function jt(){return W()}function Jt(){return W()}async function xt(t){if(!f(t))throw new TypeError('"codeVerifier" must be a non-empty string');return g(await crypto.subtle.digest("SHA-256",v(t)))}function je(t){if(t instanceof CryptoKey)return{key:t};if(!((t==null?void 0:t.key)instanceof CryptoKey))return{};if(t.kid!==void 0&&!f(t.kid))throw new TypeError('"kid" must be a non-empty string');return{key:t.key,kid:t.kid,modifyAssertion:t[Re]}}function me(t){return encodeURIComponent(t).replace(/%20/g,"+")}function Be(t,e){const n=me(t),r=me(e);return`Basic ${btoa(`${n}:${r}`)}`}function Ve(t){switch(t.algorithm.hash.name){case"SHA-256":return"PS256";case"SHA-384":return"PS384";case"SHA-512":return"PS512";default:throw new m("unsupported RsaHashedKeyAlgorithm hash name")}}function Ze(t){switch(t.algorithm.hash.name){case"SHA-256":return"RS256";case"SHA-384":return"RS384";case"SHA-512":return"RS512";default:throw new m("unsupported RsaHashedKeyAlgorithm hash name")}}function Xe(t){switch(t.algorithm.namedCurve){case"P-256":return"ES256";case"P-384":return"ES384";case"P-521":return"ES512";default:throw new m("unsupported EcKeyAlgorithm namedCurve")}}function de(t){switch(t.algorithm.name){case"RSA-PSS":return Ve(t);case"RSASSA-PKCS1-v1_5":return Ze(t);case"ECDSA":return Xe(t);case"Ed25519":case"Ed448":return"EdDSA";default:throw new m("unsupported CryptoKey algorithm name")}}function _(t){const e=t==null?void 0:t[X];return typeof e=="number"&&Number.isFinite(e)?e:0}function A(t){const e=t==null?void 0:t[Ne];return typeof e=="number"&&Number.isFinite(e)&&Math.sign(e)!==-1?e:30}function P(){return Math.floor(Date.now()/1e3)}function Qe(t,e){const n=P()+_(e);return{jti:W(),aud:[t.issuer,t.token_endpoint],exp:n+60,iat:n,nbf:n,iss:e.client_id,sub:e.client_id}}async function Ye(t,e,n,r,i){const a={alg:de(n),kid:r},o=Qe(t,e);return i==null||i(a,o),he(a,o,n)}function y(t){if(typeof t!="object"||t===null)throw new TypeError('"as" must be an object');if(!f(t.issuer))throw new TypeError('"as.issuer" property must be a non-empty string');return!0}function b(t){if(typeof t!="object"||t===null)throw new TypeError('"client" must be an object');if(!f(t.client_id))throw new TypeError('"client.client_id" property must be a non-empty string');return!0}function ye(t){if(!f(t))throw new TypeError('"client.client_secret" property must be a non-empty string');return t}function ae(t,e){if(e!==void 0)throw new TypeError(`"options.clientPrivateKey" property must not be provided when ${t} client authentication method is used.`)}function be(t,e){if(e!==void 0)throw new TypeError(`"client.client_secret" property must not be provided when ${t} client authentication method is used.`)}async function et(t,e,n,r,i){switch(n.delete("client_secret"),n.delete("client_assertion_type"),n.delete("client_assertion"),e.token_endpoint_auth_method){case void 0:case"client_secret_basic":{ae("client_secret_basic",i),r.set("authorization",Be(e.client_id,ye(e.client_secret)));break}case"client_secret_post":{ae("client_secret_post",i),n.set("client_id",e.client_id),n.set("client_secret",ye(e.client_secret));break}case"private_key_jwt":{if(be("private_key_jwt",e.client_secret),i===void 0)throw new TypeError('"options.clientPrivateKey" must be provided when "client.token_endpoint_auth_method" is "private_key_jwt"');const{key:a,kid:o,modifyAssertion:c}=je(i);if(!ce(a))throw new TypeError('"options.clientPrivateKey.key" must be a private CryptoKey');n.set("client_id",e.client_id),n.set("client_assertion_type","urn:ietf:params:oauth:client-assertion-type:jwt-bearer"),n.set("client_assertion",await Ye(t,e,a,o,c));break}case"tls_client_auth":case"self_signed_tls_client_auth":case"none":{be(e.token_endpoint_auth_method,e.client_secret),ae(e.token_endpoint_auth_method,i),n.set("client_id",e.client_id);break}default:throw new m("unsupported client token_endpoint_auth_method")}}async function he(t,e,n){if(!n.usages.includes("sign"))throw new TypeError('CryptoKey instances used for signing assertions must include "sign" in their "usages"');const r=`${g(v(JSON.stringify(t)))}.${g(v(JSON.stringify(e)))}`,i=g(await crypto.subtle.sign(De(n),n,v(r)));return`${r}.${i}`}async function Ct(t,e,n,r){y(t),b(e),n=new URLSearchParams(n);const{key:i,kid:a,modifyAssertion:o}=je(r);if(!ce(i))throw new TypeError('"privateKey.key" must be a private CryptoKey');n.set("client_id",e.client_id);const c=P()+_(e),h={...Object.fromEntries(n.entries()),jti:W(),aud:t.issuer,exp:c+60,iat:c,nbf:c,iss:e.client_id};let w;n.has("resource")&&(w=n.getAll("resource"))&&w.length>1&&(h.resource=w);{let u=n.get("max_age");if(u!==null&&(h.max_age=parseInt(u,10),!Number.isFinite(h.max_age)))throw new s('"max_age" parameter must be a number')}{let u=n.get("claims");if(u!==null){try{h.claims=JSON.parse(u)}catch(d){throw new s('failed to parse the "claims" parameter as JSON',{cause:d})}if(!S(h.claims))throw new s('"claims" parameter must be a JSON with a top level object')}}{let u=n.get("authorization_details");if(u!==null){try{h.authorization_details=JSON.parse(u)}catch(d){throw new s('failed to parse the "authorization_details" parameter as JSON',{cause:d})}if(!Array.isArray(h.authorization_details))throw new s('"authorization_details" parameter must be a JSON with a top level array')}}const p={alg:de(i),typ:"oauth-authz-req+jwt",kid:a};return o==null||o(p,h),he(p,h,i)}async function fe(t,e,n,r,i,a){var d;const{privateKey:o,publicKey:c,nonce:h=Ee.get(n.origin)}=e;if(!ce(o))throw new TypeError('"DPoP.privateKey" must be a private CryptoKey');if(!Ge(c))throw new TypeError('"DPoP.publicKey" must be a public CryptoKey');if(h!==void 0&&!f(h))throw new TypeError('"DPoP.nonce" must be a non-empty string or undefined');if(!c.extractable)throw new TypeError('"DPoP.publicKey.extractable" must be true');const w=P()+i,p={alg:de(o),typ:"dpop+jwt",jwk:await nt(c)},u={iat:w,jti:W(),htm:r,nonce:h,htu:`${n.origin}${n.pathname}`,ath:a?g(await crypto.subtle.digest("SHA-256",v(a))):void 0};(d=e[Re])==null||d.call(e,p,u),t.set("dpop",await he(p,u,o))}let Z;async function tt(t){const{kty:e,e:n,n:r,x:i,y:a,crv:o}=await crypto.subtle.exportKey("jwk",t),c={kty:e,e:n,n:r,x:i,y:a,crv:o};return Z.set(t,c),c}async function nt(t){return Z||(Z=new WeakMap),Z.get(t)||tt(t)}function ge(t,e,n){if(typeof t!="string")throw n?new TypeError(`"as.mtls_endpoint_aliases.${e}" must be a string`):new TypeError(`"as.${e}" must be a string`);return new URL(t)}function D(t,e,n=!1){return n&&t.mtls_endpoint_aliases&&e in t.mtls_endpoint_aliases?ge(t.mtls_endpoint_aliases[e],e,n):ge(t[e],e,n)}function H(t,e){return!!(t.use_mtls_endpoint_aliases||e!=null&&e[oe])}async function Dt(t,e,n,r){y(t),b(e);const i=D(t,"pushed_authorization_request_endpoint",H(e,r)),a=new URLSearchParams(n);a.set("client_id",e.client_id);const o=j(r==null?void 0:r.headers);return o.set("accept","application/json"),(r==null?void 0:r.DPoP)!==void 0&&await fe(o,r.DPoP,i,"POST",_(e)),M(t,e,"POST",i,a,o,r)}function ne(t){const e=t;return typeof e!="object"||Array.isArray(e)||e===null?!1:e.error!==void 0}function rt(t){return t.length>=2&&t[0]==='"'&&t[t.length-1]==='"'?t.slice(1,-1):t}const at=/((?:,|, )?[0-9a-zA-Z!#$%&'*+-.^_`|~]+=)/,it=/(?:^|, ?)([0-9a-zA-Z!#$%&'*+\-.^_`|~]+)(?=$|[ ,])/g;function st(t,e){const n=e.split(at).slice(1);if(!n.length)return{scheme:t.toLowerCase(),parameters:{}};n[n.length-1]=n[n.length-1].replace(/,$/,"");const r={};for(let i=1;i<n.length;i+=2){const a=i;if(n[a][0]==='"')for(;n[a].slice(-1)!=='"'&&++i<n.length;)n[a]+=n[i];const o=n[a-1].replace(/^(?:, ?)|=$/g,"").toLowerCase();r[o]=rt(n[a])}return{scheme:t.toLowerCase(),parameters:r}}function Ut(t){if(!R(t,Response))throw new TypeError('"response" must be an instance of Response');const e=t.headers.get("www-authenticate");if(e===null)return;const n=[];for(const{1:i,index:a}of e.matchAll(it))n.push([i,a]);return n.length?n.map(([i,a],o,c)=>{const h=c[o+1];let w;return h?w=e.slice(a,h[1]):w=e.slice(a),st(i,w)}):void 0}async function Ot(t,e,n){if(y(t),b(e),!R(n,Response))throw new TypeError('"response" must be an instance of Response');if(n.status!==201){let i;if(i=await B(n))return i;throw new s('"response" is not a conform Pushed Authorization Request Endpoint response')}E(n);let r;try{r=await n.json()}catch(i){throw new s('failed to parse "response" body as JSON',{cause:i})}if(!S(r))throw new s('"response" body must be a top level object');if(!f(r.request_uri))throw new s('"response" body "request_uri" property must be a non-empty string');if(typeof r.expires_in!="number"||r.expires_in<=0)throw new s('"response" body "expires_in" property must be a positive number');return r}async function ot(t,e,n,r,i,a){if(!f(t))throw new TypeError('"accessToken" must be a non-empty string');if(!(n instanceof URL))throw new TypeError('"url" must be an instance of URL');return r=j(r),(a==null?void 0:a.DPoP)===void 0?r.set("authorization",`Bearer ${t}`):(await fe(r,a.DPoP,n,e.toUpperCase(),_({[X]:a==null?void 0:a[X]}),t),r.set("authorization",`DPoP ${t}`)),((a==null?void 0:a[L])||fetch)(n.href,{body:i,headers:Object.fromEntries(r.entries()),method:e,redirect:"manual",signal:a!=null&&a.signal?te(a.signal):null}).then(ee)}async function zt(t,e,n,r){y(t),b(e);const i=D(t,"userinfo_endpoint",H(e,r)),a=j(r==null?void 0:r.headers);return e.userinfo_signed_response_alg?a.set("accept","application/jwt"):(a.set("accept","application/json"),a.append("accept","application/jwt")),ot(n,"GET",i,a,null,{...r,[X]:_(e)})}let k;function _e(t,e,n,r){k||(k=new WeakMap),k.set(t,{jwks:e,uat:n,get age(){return P()-this.uat}}),r&&Object.assign(r,{jwks:structuredClone(e),uat:n})}function ct(t){return!(typeof t!="object"||t===null||!("uat"in t)||typeof t.uat!="number"||P()-t.uat>=300||!("jwks"in t)||!S(t.jwks)||!Array.isArray(t.jwks.keys)||!Array.prototype.every.call(t.jwks.keys,S))}function Se(t,e){k==null||k.delete(t),e==null||delete e.jwks,e==null||delete e.uat}async function C(t,e,n){const{alg:r,kid:i}=n;gt(r),!(k!=null&&k.has(t))&&ct(e==null?void 0:e[x])&&_e(t,e==null?void 0:e[x].jwks,e==null?void 0:e[x].uat);let a,o;if(k!=null&&k.has(t)){if({jwks:a,age:o}=k.get(t),o>=300)return Se(t,e==null?void 0:e[x]),C(t,e,n)}else a=await yt(t,e).then(bt),o=0,_e(t,a,P(),e==null?void 0:e[x]);let c;switch(r.slice(0,2)){case"RS":case"PS":c="RSA";break;case"ES":c="EC";break;case"Ed":c="OKP";break;default:throw new m}const h=a.keys.filter(d=>{var l;if(d.kty!==c||i!==void 0&&i!==d.kid||d.alg!==void 0&&r!==d.alg||d.use!==void 0&&d.use!=="sig"||((l=d.key_ops)==null?void 0:l.includes("verify"))===!1)return!1;switch(!0){case(r==="ES256"&&d.crv!=="P-256"):case(r==="ES384"&&d.crv!=="P-384"):case(r==="ES512"&&d.crv!=="P-521"):case(r==="EdDSA"&&!(d.crv==="Ed25519"||d.crv==="Ed448")):return!1}return!0}),{0:w,length:p}=h;if(!p){if(o>=60)return Se(t,e==null?void 0:e[x]),C(t,e,n);throw new s("error when selecting a JWT verification key, no applicable keys found")}if(p!==1)throw new s('error when selecting a JWT verification key, multiple applicable keys found, a "kid" JWT Header Parameter is required');const u=await Le(r,w);if(u.type!=="public")throw new s("jwks_uri must only contain public keys");return u}const ut=Symbol();function Je(t){var e;return(e=t.headers.get("content-type"))==null?void 0:e.split(";")[0]}async function Lt(t,e,n,r){if(y(t),b(e),!R(r,Response))throw new TypeError('"response" must be an instance of Response');if(r.status!==200)throw new s('"response" is not a conform UserInfo Endpoint response');let i;if(Je(r)==="application/jwt"){E(r);const{claims:a,jwt:o}=await U(await r.text(),O.bind(void 0,e.userinfo_signed_response_alg,t.userinfo_signing_alg_values_supported),re,_(e),A(e),e[q]).then(ft.bind(void 0,e.client_id)).then(wt.bind(void 0,t.issuer));Y.set(r,o),i=a}else{if(e.userinfo_signed_response_alg)throw new s("JWT UserInfo Response expected");E(r);try{i=await r.json()}catch(a){throw new s('failed to parse "response" body as JSON',{cause:a})}}if(!S(i))throw new s('"response" body must be a top level object');if(!f(i.sub))throw new s('"response" body "sub" property must be a non-empty string');switch(n){case ut:break;default:if(!f(n))throw new s('"expectedSubject" must be a non-empty string');if(i.sub!==n)throw new s('unexpected "response" body "sub" value')}return i}async function M(t,e,n,r,i,a,o){return await et(t,e,i,a,o==null?void 0:o.clientPrivateKey),a.set("content-type","application/x-www-form-urlencoded;charset=UTF-8"),((o==null?void 0:o[L])||fetch)(r.href,{body:i,headers:Object.fromEntries(a.entries()),method:n,redirect:"manual",signal:o!=null&&o.signal?te(o.signal):null}).then(ee)}async function G(t,e,n,r,i){const a=D(t,"token_endpoint",H(e,i));r.set("grant_type",n);const o=j(i==null?void 0:i.headers);return o.set("accept","application/json"),(i==null?void 0:i.DPoP)!==void 0&&await fe(o,i.DPoP,a,"POST",_(e)),M(t,e,"POST",a,r,o,i)}async function Wt(t,e,n,r){if(y(t),b(e),!f(n))throw new TypeError('"refreshToken" must be a non-empty string');const i=new URLSearchParams(r==null?void 0:r.additionalParameters);return i.set("refresh_token",n),G(t,e,"refresh_token",i,r)}const Q=new WeakMap,Y=new WeakMap;function dt(t){if(!t.id_token)return;const e=Q.get(t);if(!e)throw new TypeError('"ref" was already garbage collected or did not resolve from the proper sources');return e[0]}async function Ht(t,e,n){if(y(t),!Q.has(e))throw new s('"ref" does not contain an ID Token to verify the signature of');const{0:r,1:i,2:a}=Q.get(e)[1].split("."),o=JSON.parse(v(g(r)));if(o.alg.startsWith("HS"))throw new m;let c;c=await C(t,n,o),await le(r,i,c,g(a))}async function xe(t,e,n){if(y(t),!Y.has(e))throw new s('"ref" does not contain a processed JWT Response to verify the signature of');const{0:r,1:i,2:a}=Y.get(e).split("."),o=JSON.parse(v(g(r)));if(o.alg.startsWith("HS"))throw new m;let c;c=await C(t,n,o),await le(r,i,c,g(a))}function ht(t,e,n){return xe(t,e,n)}function Nt(t,e,n){return xe(t,e,n)}async function F(t,e,n,r=!1,i=!1){if(y(t),b(e),!R(n,Response))throw new TypeError('"response" must be an instance of Response');if(n.status!==200){let o;if(o=await B(n))return o;throw new s('"response" is not a conform Token Endpoint response')}E(n);let a;try{a=await n.json()}catch(o){throw new s('failed to parse "response" body as JSON',{cause:o})}if(!S(a))throw new s('"response" body must be a top level object');if(!f(a.access_token))throw new s('"response" body "access_token" property must be a non-empty string');if(!f(a.token_type))throw new s('"response" body "token_type" property must be a non-empty string');if(a.token_type=a.token_type.toLowerCase(),a.token_type!=="dpop"&&a.token_type!=="bearer")throw new m("unsupported `token_type` value");if(a.expires_in!==void 0&&(typeof a.expires_in!="number"||a.expires_in<=0))throw new s('"response" body "expires_in" property must be a positive number');if(!i&&a.refresh_token!==void 0&&!f(a.refresh_token))throw new s('"response" body "refresh_token" property must be a non-empty string');if(a.scope!==void 0&&typeof a.scope!="string")throw new s('"response" body "scope" property must be a string');if(!r){if(a.id_token!==void 0&&!f(a.id_token))throw new s('"response" body "id_token" property must be a non-empty string');if(a.id_token){const{claims:o,jwt:c}=await U(a.id_token,O.bind(void 0,e.id_token_signed_response_alg,t.id_token_signing_alg_values_supported),re,_(e),A(e),e[q]).then(K.bind(void 0,["aud","exp","iat","iss","sub"])).then(I.bind(void 0,t.issuer)).then(N.bind(void 0,e.client_id));if(Array.isArray(o.aud)&&o.aud.length!==1){if(o.azp===void 0)throw new s('ID Token "aud" (audience) claim includes additional untrusted audiences');if(o.azp!==e.client_id)throw new s('unexpected ID Token "azp" (authorized party) claim value')}if(o.auth_time!==void 0&&(!Number.isFinite(o.auth_time)||Math.sign(o.auth_time)!==1))throw new s('ID Token "auth_time" (authentication time) must be a positive number');Q.set(a,[o,c])}}return a}async function It(t,e,n){return F(t,e,n)}function ft(t,e){return e.claims.aud!==void 0?N(t,e):e}function N(t,e){if(Array.isArray(e.claims.aud)){if(!e.claims.aud.includes(t))throw new s('unexpected JWT "aud" (audience) claim value')}else if(e.claims.aud!==t)throw new s('unexpected JWT "aud" (audience) claim value');return e}function wt(t,e){return e.claims.iss!==void 0?I(t,e):e}function I(t,e){if(e.claims.iss!==t)throw new s('unexpected JWT "iss" (issuer) claim value');return e}const Ce=new WeakSet;function lt(t){return Ce.add(t),t}async function Kt(t,e,n,r,i,a){if(y(t),b(e),!Ce.has(n))throw new TypeError('"callbackParameters" must be an instance of URLSearchParams obtained from "validateAuthResponse()", or "validateJwtAuthResponse()');if(!f(r))throw new TypeError('"redirectUri" must be a non-empty string');if(!f(i))throw new TypeError('"codeVerifier" must be a non-empty string');const o=T(n,"code");if(!o)throw new s('no authorization code in "callbackParameters"');const c=new URLSearchParams(a==null?void 0:a.additionalParameters);return c.set("redirect_uri",r),c.set("code_verifier",i),c.set("code",o),G(t,e,"authorization_code",c,a)}const pt={aud:"audience",c_hash:"code hash",client_id:"client id",exp:"expiration time",iat:"issued at",iss:"issuer",jti:"jwt id",nonce:"nonce",s_hash:"state hash",sub:"subject",ath:"access token hash",htm:"http method",htu:"http uri",cnf:"confirmation"};function K(t,e){for(const n of t)if(e.claims[n]===void 0)throw new s(`JWT "${n}" (${pt[n]}) claim missing`);return e}const mt=Symbol(),z=Symbol();async function $t(t,e,n,r,i){const a=await F(t,e,n);if(ne(a))return a;if(!f(a.id_token))throw new s('"response" body "id_token" property must be a non-empty string');i??(i=e.default_max_age??z);const o=dt(a);if((e.require_auth_time||i!==z)&&o.auth_time===void 0)throw new s('ID Token "auth_time" (authentication time) claim missing');if(i!==z){if(typeof i!="number"||i<0)throw new TypeError('"maxAge" must be a non-negative number');const c=P()+_(e),h=A(e);if(o.auth_time+i<c-h)throw new s("too much time has elapsed since the last End-User authentication")}switch(r){case void 0:case mt:if(o.nonce!==void 0)throw new s('unexpected ID Token "nonce" claim value');break;default:if(!f(r))throw new TypeError('"expectedNonce" must be a non-empty string');if(o.nonce===void 0)throw new s('ID Token "nonce" claim missing');if(o.nonce!==r)throw new s('unexpected ID Token "nonce" claim value')}return a}async function qt(t,e,n){const r=await F(t,e,n,!0);if(ne(r))return r;if(r.id_token!==void 0){if(typeof r.id_token=="string"&&r.id_token.length)throw new s("Unexpected ID Token returned, use processAuthorizationCodeOpenIDResponse() for OpenID Connect callback processing");delete r.id_token}return r}function we(t,e){if(typeof e.header.typ!="string"||Fe(e.header.typ)!==t)throw new s('unexpected JWT "typ" header parameter value');return e}async function Mt(t,e,n,r){return y(t),b(e),G(t,e,"client_credentials",new URLSearchParams(n),r)}async function Gt(t,e,n,r,i){if(y(t),b(e),!f(n))throw new TypeError('"grantType" must be a non-empty string');return G(t,e,n,new URLSearchParams(r),i)}async function Ft(t,e,n){const r=await F(t,e,n,!0,!0);return ne(r),r}async function Bt(t,e,n,r){if(y(t),b(e),!f(n))throw new TypeError('"token" must be a non-empty string');const i=D(t,"revocation_endpoint",H(e,r)),a=new URLSearchParams(r==null?void 0:r.additionalParameters);a.set("token",n);const o=j(r==null?void 0:r.headers);return o.delete("accept"),M(t,e,"POST",i,a,o,r)}async function Vt(t){if(!R(t,Response))throw new TypeError('"response" must be an instance of Response');if(t.status!==200){let e;if(e=await B(t))return e;throw new s('"response" is not a conform Revocation Endpoint response')}}function E(t){if(t.bodyUsed)throw new TypeError('"response" body has been used already')}async function Zt(t,e,n,r){if(y(t),b(e),!f(n))throw new TypeError('"token" must be a non-empty string');const i=D(t,"introspection_endpoint",H(e,r)),a=new URLSearchParams(r==null?void 0:r.additionalParameters);a.set("token",n);const o=j(r==null?void 0:r.headers);return(r==null?void 0:r.requestJwtResponse)??e.introspection_signed_response_alg?o.set("accept","application/token-introspection+jwt"):o.set("accept","application/json"),M(t,e,"POST",i,a,o,r)}async function Xt(t,e,n){if(y(t),b(e),!R(n,Response))throw new TypeError('"response" must be an instance of Response');if(n.status!==200){let i;if(i=await B(n))return i;throw new s('"response" is not a conform Introspection Endpoint response')}let r;if(Je(n)==="application/token-introspection+jwt"){E(n);const{claims:i,jwt:a}=await U(await n.text(),O.bind(void 0,e.introspection_signed_response_alg,t.introspection_signing_alg_values_supported),re,_(e),A(e),e[q]).then(we.bind(void 0,"token-introspection+jwt")).then(K.bind(void 0,["aud","iat","iss"])).then(I.bind(void 0,t.issuer)).then(N.bind(void 0,e.client_id));if(Y.set(n,a),r=i.token_introspection,!S(r))throw new s('JWT "token_introspection" claim must be a JSON object')}else{E(n);try{r=await n.json()}catch(i){throw new s('failed to parse "response" body as JSON',{cause:i})}if(!S(r))throw new s('"response" body must be a top level object')}if(typeof r.active!="boolean")throw new s('"response" body "active" property must be a boolean');return r}async function yt(t,e){y(t);const n=D(t,"jwks_uri"),r=j(e==null?void 0:e.headers);return r.set("accept","application/json"),r.append("accept","application/jwk-set+json"),((e==null?void 0:e[L])||fetch)(n.href,{headers:Object.fromEntries(r.entries()),method:"GET",redirect:"manual",signal:e!=null&&e.signal?te(e.signal):null}).then(ee)}async function bt(t){if(!R(t,Response))throw new TypeError('"response" must be an instance of Response');if(t.status!==200)throw new s('"response" is not a conform JSON Web Key Set response');E(t);let e;try{e=await t.json()}catch(n){throw new s('failed to parse "response" body as JSON',{cause:n})}if(!S(e))throw new s('"response" body must be a top level object');if(!Array.isArray(e.keys))throw new s('"response" body "keys" property must be an array');if(!Array.prototype.every.call(e.keys,S))throw new s('"response" body "keys" property members must be JWK formatted objects');return e}async function B(t){if(t.status>399&&t.status<500){E(t);try{const e=await t.json();if(S(e)&&typeof e.error=="string"&&e.error.length)return e.error_description!==void 0&&typeof e.error_description!="string"&&delete e.error_description,e.error_uri!==void 0&&typeof e.error_uri!="string"&&delete e.error_uri,e.algs!==void 0&&typeof e.algs!="string"&&delete e.algs,e.scope!==void 0&&typeof e.scope!="string"&&delete e.scope,e}catch{}}}function gt(t){if(!ue.includes(t))throw new m('unsupported JWS "alg" identifier');return t}function ke(t){if(typeof t.modulusLength!="number"||t.modulusLength<2048)throw new s(`${t.name} modulusLength must be at least 2048 bits`)}function _t(t){switch(t){case"P-256":return"SHA-256";case"P-384":return"SHA-384";case"P-521":return"SHA-512";default:throw new m}}function De(t){switch(t.algorithm.name){case"ECDSA":return{name:t.algorithm.name,hash:_t(t.algorithm.namedCurve)};case"RSA-PSS":switch(ke(t.algorithm),t.algorithm.hash.name){case"SHA-256":case"SHA-384":case"SHA-512":return{name:t.algorithm.name,saltLength:parseInt(t.algorithm.hash.name.slice(-3),10)>>3};default:throw new m}case"RSASSA-PKCS1-v1_5":return ke(t.algorithm),t.algorithm.name;case"Ed448":case"Ed25519":return t.algorithm.name}throw new m}const re=Symbol();async function le(t,e,n,r){const i=`${t}.${e}`;if(!await crypto.subtle.verify(De(n),n,r,v(i)))throw new s("JWT signature verification failed")}async function U(t,e,n,r,i,a){let{0:o,1:c,2:h,length:w}=t.split(".");if(w===5)if(a!==void 0)t=await a(t),{0:o,1:c,2:h,length:w}=t.split(".");else throw new m("JWE structure JWTs are not supported");if(w!==3)throw new s("Invalid JWT");let p;try{p=JSON.parse(v(g(o)))}catch($){throw new s("failed to parse JWT Header body as base64url encoded JSON",{cause:$})}if(!S(p))throw new s("JWT Header must be a top level object");if(e(p),p.crit!==void 0)throw new s('unexpected JWT "crit" header parameter');const u=g(h);let d;n!==re&&(d=await n(p),await le(o,c,d,u));let l;try{l=JSON.parse(v(g(c)))}catch($){throw new s("failed to parse JWT Payload body as base64url encoded JSON",{cause:$})}if(!S(l))throw new s("JWT Payload must be a top level object");const J=P()+r;if(l.exp!==void 0){if(typeof l.exp!="number")throw new s('unexpected JWT "exp" (expiration time) claim type');if(l.exp<=J-i)throw new s('unexpected JWT "exp" (expiration time) claim value, timestamp is <= now()')}if(l.iat!==void 0&&typeof l.iat!="number")throw new s('unexpected JWT "iat" (issued at) claim type');if(l.iss!==void 0&&typeof l.iss!="string")throw new s('unexpected JWT "iss" (issuer) claim type');if(l.nbf!==void 0){if(typeof l.nbf!="number")throw new s('unexpected JWT "nbf" (not before) claim type');if(l.nbf>J+i)throw new s('unexpected JWT "nbf" (not before) claim value, timestamp is > now()')}if(l.aud!==void 0&&typeof l.aud!="string"&&!Array.isArray(l.aud))throw new s('unexpected JWT "aud" (audience) claim type');return{header:p,claims:l,signature:u,key:d,jwt:t}}async function Qt(t,e,n,r,i){if(y(t),b(e),n instanceof URL&&(n=n.searchParams),!(n instanceof URLSearchParams))throw new TypeError('"parameters" must be an instance of URLSearchParams, or URL');const a=T(n,"response");if(!a)throw new s('"parameters" does not contain a JARM response');const{claims:o}=await U(a,O.bind(void 0,e.authorization_signed_response_alg,t.authorization_signing_alg_values_supported),C.bind(void 0,t,i),_(e),A(e),e[q]).then(K.bind(void 0,["aud","exp","iss"])).then(I.bind(void 0,t.issuer)).then(N.bind(void 0,e.client_id)),c=new URLSearchParams;for(const[h,w]of Object.entries(o))typeof w=="string"&&h!=="aud"&&c.set(h,w);return Oe(t,e,c,r)}async function St(t,e,n){let r;switch(t){case"RS256":case"PS256":case"ES256":r="SHA-256";break;case"RS384":case"PS384":case"ES384":r="SHA-384";break;case"RS512":case"PS512":case"ES512":r="SHA-512";break;case"EdDSA":if(n.algorithm.name==="Ed25519"){r="SHA-512";break}throw new m;default:throw new m}const i=await crypto.subtle.digest(r,v(e));return g(i.slice(0,i.byteLength/2))}async function Te(t,e,n,r){const i=await St(n,t,r);return e===i}async function kt(t,e,n,r,i,a,o){if(y(t),b(e),n instanceof URL){if(!n.hash.length)throw new TypeError('"parameters" as an instance of URL must contain a hash (fragment) with the Authorization Response parameters');n=new URLSearchParams(n.hash.slice(1))}if(!(n instanceof URLSearchParams))throw new TypeError('"parameters" must be an instance of URLSearchParams');n=new URLSearchParams(n);const c=T(n,"id_token");switch(n.delete("id_token"),i){case void 0:case Ue:break;default:if(!f(i))throw new TypeError('"expectedState" must be a non-empty string')}const h=Oe({...t,authorization_response_iss_parameter_supported:!1},e,n,i);if(ne(h))return h;if(!c)throw new s('"parameters" does not contain an ID Token');const w=T(n,"code");if(!w)throw new s('"parameters" does not contain an Authorization Code');const p=["aud","exp","iat","iss","sub","nonce","c_hash"];typeof i=="string"&&p.push("s_hash");const{claims:u,header:d,key:l}=await U(c,O.bind(void 0,e.id_token_signed_response_alg,t.id_token_signing_alg_values_supported),C.bind(void 0,t,o),_(e),A(e),e[q]).then(K.bind(void 0,p)).then(I.bind(void 0,t.issuer)).then(N.bind(void 0,e.client_id)),J=_(e),$=P()+J;if(u.iat<$-3600)throw new s('unexpected JWT "iat" (issued at) claim value, it is too far in the past');if(typeof u.c_hash!="string"||await Te(w,u.c_hash,d.alg,l)!==!0)throw new s('invalid ID Token "c_hash" (code hash) claim value');if(u.s_hash!==void 0&&typeof i!="string")throw new s('could not verify ID Token "s_hash" (state hash) claim value');if(typeof i=="string"&&(typeof u.s_hash!="string"||await Te(i,u.s_hash,d.alg,l)!==!0))throw new s('invalid ID Token "s_hash" (state hash) claim value');if(u.auth_time!==void 0&&(!Number.isFinite(u.auth_time)||Math.sign(u.auth_time)!==1))throw new s('ID Token "auth_time" (authentication time) must be a positive number');if(a??(a=e.default_max_age??z),(e.require_auth_time||a!==z)&&u.auth_time===void 0)throw new s('ID Token "auth_time" (authentication time) claim missing');if(a!==z){if(typeof a!="number"||a<0)throw new TypeError('"maxAge" must be a non-negative number');const We=P()+_(e),He=A(e);if(u.auth_time+a<We-He)throw new s("too much time has elapsed since the last End-User authentication")}if(!f(r))throw new TypeError('"expectedNonce" must be a non-empty string');if(u.nonce!==r)throw new s('unexpected ID Token "nonce" claim value');if(Array.isArray(u.aud)&&u.aud.length!==1){if(u.azp===void 0)throw new s('ID Token "aud" (audience) claim includes additional untrusted audiences');if(u.azp!==e.client_id)throw new s('unexpected ID Token "azp" (authorized party) claim value')}return h}function O(t,e,n){if(t!==void 0){if(n.alg!==t)throw new s('unexpected JWT "alg" header parameter');return}if(Array.isArray(e)){if(!e.includes(n.alg))throw new s('unexpected JWT "alg" header parameter');return}if(n.alg!=="RS256")throw new s('unexpected JWT "alg" header parameter')}function T(t,e){const{0:n,length:r}=t.getAll(e);if(r>1)throw new s(`"${e}" parameter must be provided only once`);return n}const Tt=Symbol(),Ue=Symbol();function Oe(t,e,n,r){if(y(t),b(e),n instanceof URL&&(n=n.searchParams),!(n instanceof URLSearchParams))throw new TypeError('"parameters" must be an instance of URLSearchParams, or URL');if(T(n,"response"))throw new s('"parameters" contains a JARM response, use validateJwtAuthResponse() instead of validateAuthResponse()');const i=T(n,"iss"),a=T(n,"state");if(!i&&t.authorization_response_iss_parameter_supported)throw new s('response parameter "iss" (issuer) missing');if(i&&i!==t.issuer)throw new s('unexpected "iss" (issuer) response parameter value');switch(r){case void 0:case Ue:if(a!==void 0)throw new s('unexpected "state" response parameter encountered');break;case Tt:break;default:if(!f(r))throw new s('"expectedState" must be a non-empty string');if(a===void 0)throw new s('response parameter "state" missing');if(a!==r)throw new s('unexpected "state" response parameter value')}const o=T(n,"error");if(o)return{error:o,error_description:T(n,"error_description"),error_uri:T(n,"error_uri")};const c=T(n,"id_token"),h=T(n,"token");if(c!==void 0||h!==void 0)throw new m("implicit and hybrid flows are not supported");return lt(new URLSearchParams(n))}function ze(t,e){switch(t){case"PS256":case"PS384":case"PS512":return{name:"RSA-PSS",hash:`SHA-${t.slice(-3)}`};case"RS256":case"RS384":case"RS512":return{name:"RSASSA-PKCS1-v1_5",hash:`SHA-${t.slice(-3)}`};case"ES256":case"ES384":return{name:"ECDSA",namedCurve:`P-${t.slice(-3)}`};case"ES512":return{name:"ECDSA",namedCurve:"P-521"};case"EdDSA":switch(e){case"Ed25519":case"Ed448":return e;default:throw new m}default:throw new m}}async function Le(t,e){const{ext:n,key_ops:r,use:i,...a}=e;return crypto.subtle.importKey("jwk",a,ze(t,e.crv),!0,["verify"])}async function Yt(t,e,n,r){y(t),b(e);const i=D(t,"device_authorization_endpoint",H(e,r)),a=new URLSearchParams(n);a.set("client_id",e.client_id);const o=j(r==null?void 0:r.headers);return o.set("accept","application/json"),M(t,e,"POST",i,a,o,r)}async function en(t,e,n){if(y(t),b(e),!R(n,Response))throw new TypeError('"response" must be an instance of Response');if(n.status!==200){let i;if(i=await B(n))return i;throw new s('"response" is not a conform Device Authorization Endpoint response')}E(n);let r;try{r=await n.json()}catch(i){throw new s('failed to parse "response" body as JSON',{cause:i})}if(!S(r))throw new s('"response" body must be a top level object');if(!f(r.device_code))throw new s('"response" body "device_code" property must be a non-empty string');if(!f(r.user_code))throw new s('"response" body "user_code" property must be a non-empty string');if(!f(r.verification_uri))throw new s('"response" body "verification_uri" property must be a non-empty string');if(typeof r.expires_in!="number"||r.expires_in<=0)throw new s('"response" body "expires_in" property must be a positive number');if(r.verification_uri_complete!==void 0&&!f(r.verification_uri_complete))throw new s('"response" body "verification_uri_complete" property must be a non-empty string');if(r.interval!==void 0&&(typeof r.interval!="number"||r.interval<=0))throw new s('"response" body "interval" property must be a positive number');return r}async function tn(t,e,n,r){if(y(t),b(e),!f(n))throw new TypeError('"deviceCode" must be a non-empty string');const i=new URLSearchParams(r==null?void 0:r.additionalParameters);return i.set("device_code",n),G(t,e,"urn:ietf:params:oauth:grant-type:device_code",i,r)}async function nn(t,e,n){return F(t,e,n)}async function rn(t,e){if(!f(t))throw new TypeError('"alg" must be a non-empty string');const n=ze(t,t==="EdDSA"?(e==null?void 0:e.crv)??"Ed25519":void 0);return(t.startsWith("PS")||t.startsWith("RS"))&&Object.assign(n,{modulusLength:(e==null?void 0:e.modulusLength)??2048,publicExponent:new Uint8Array([1,0,1])}),crypto.subtle.generateKey(n,(e==null?void 0:e.extractable)??!1,["sign","verify"])}function ve(t){const e=new URL(t);return e.search="",e.hash="",e.href}async function vt(t,e,n,r,i){var p,u;const a=e.headers.get("dpop");if(a===null)throw new s("operation indicated DPoP use but the request has no DPoP HTTP Header");if(((p=e.headers.get("authorization"))==null?void 0:p.toLowerCase().startsWith("dpop "))===!1)throw new s("operation indicated DPoP use but the request's Authorization HTTP Header scheme is not DPoP");if(typeof((u=r.cnf)==null?void 0:u.jkt)!="string")throw new s("operation indicated DPoP use but the JWT Access Token has no jkt confirmation claim");const o=_(i),c=await U(a,O.bind(void 0,void 0,(t==null?void 0:t.dpop_signing_alg_values_supported)||ue),async({jwk:d,alg:l})=>{if(!d)throw new s("DPoP Proof is missing the jwk header parameter");const J=await Le(l,d);if(J.type!=="public")throw new s("DPoP Proof jwk header parameter must contain a public key");return J},o,A(i),void 0).then(we.bind(void 0,"dpop+jwt")).then(K.bind(void 0,["iat","jti","ath","htm","htu"])),h=P()+o;if(Math.abs(h-c.claims.iat)>300)throw new s("DPoP Proof iat is not recent enough");if(c.claims.htm!==e.method)throw new s("DPoP Proof htm mismatch");if(typeof c.claims.htu!="string"||ve(c.claims.htu)!==ve(e.url))throw new s("DPoP Proof htu mismatch");{const d=g(await crypto.subtle.digest("SHA-256",se.encode(n)));if(c.claims.ath!==d)throw new s("DPoP Proof ath mismatch")}{let d;switch(c.header.jwk.kty){case"EC":d={crv:c.header.jwk.crv,kty:c.header.jwk.kty,x:c.header.jwk.x,y:c.header.jwk.y};break;case"OKP":d={crv:c.header.jwk.crv,kty:c.header.jwk.kty,x:c.header.jwk.x};break;case"RSA":d={e:c.header.jwk.e,kty:c.header.jwk.kty,n:c.header.jwk.n};break;default:throw new m}const l=g(await crypto.subtle.digest("SHA-256",se.encode(JSON.stringify(d))));if(r.cnf.jkt!==l)throw new s("JWT Access Token confirmation mismatch")}}async function Pt(t,e,n,r){var p;if(y(t),!R(e,Request))throw new TypeError('"request" must be an instance of Request');if(!f(n))throw new s('"expectedAudience" must be a non-empty string');const i=e.headers.get("authorization");if(i===null)throw new s('"request" is missing an Authorization HTTP Header');let{0:a,1:o,length:c}=i.split(" ");switch(a=a.toLowerCase(),a){case"dpop":case"bearer":break;default:throw new m("unsupported Authorization HTTP Header scheme")}if(c!==2)throw new s("invalid Authorization HTTP Header format");const h=["iss","exp","aud","sub","iat","jti","client_id"];(r!=null&&r.requireDPoP||a==="dpop"||e.headers.has("dpop"))&&h.push("cnf");const{claims:w}=await U(o,O.bind(void 0,void 0,ue),C.bind(void 0,t,r),_(r),A(r),void 0).then(we.bind(void 0,"at+jwt")).then(K.bind(void 0,h)).then(I.bind(void 0,t.issuer)).then(N.bind(void 0,n));for(const u of["client_id","jti","sub"])if(typeof w[u]!="string")throw new s(`unexpected JWT "${u}" claim type`);if("cnf"in w){if(!S(w.cnf))throw new s('unexpected JWT "cnf" (confirmation) claim value');const{0:u,length:d}=Object.keys(w.cnf);if(d){if(d!==1)throw new m("multiple confirmation claims are not supported");if(u!=="jkt")throw new m("unsupported JWT Confirmation method")}}return(r!=null&&r.requireDPoP||a==="dpop"||((p=w.cnf)==null?void 0:p.jkt)!==void 0||e.headers.has("dpop"))&&await vt(t,e,o,w,r),w}const an=L,sn=L,on=oe,cn=oe,un=(...t)=>kt(...t),dn=(...t)=>Pt(...t),hn=(...t)=>ht(...t),fn=x;export{Me as OperationProcessingError,m as UnsupportedOperationError,Kt as authorizationCodeGrantRequest,xt as calculatePKCECodeChallenge,Mt as clientCredentialsGrantRequest,X as clockSkew,Ne as clockTolerance,L as customFetch,Yt as deviceAuthorizationRequest,tn as deviceCodeGrantRequest,Rt as discoveryRequest,mt as expectNoNonce,Ue as expectNoState,an as experimentalCustomFetch,on as experimentalUseMtlsAlias,sn as experimental_customFetch,fn as experimental_jwksCache,cn as experimental_useMtlsAlias,un as experimental_validateDetachedSignatureResponse,dn as experimental_validateJwtAccessToken,rn as generateKeyPair,At as generateRandomCodeVerifier,Jt as generateRandomNonce,jt as generateRandomState,Gt as genericTokenEndpointRequest,dt as getValidatedIdTokenClaims,Zt as introspectionRequest,ne as isOAuth2Error,Ct as issueRequestObject,q as jweDecrypt,x as jwksCache,Re as modifyAssertion,Ut as parseWwwAuthenticateChallenges,qt as processAuthorizationCodeOAuth2Response,$t as processAuthorizationCodeOpenIDResponse,Ft as processClientCredentialsResponse,en as processDeviceAuthorizationResponse,nn as processDeviceCodeResponse,Et as processDiscoveryResponse,Xt as processIntrospectionResponse,Ot as processPushedAuthorizationResponse,It as processRefreshTokenResponse,Vt as processRevocationResponse,Lt as processUserInfoResponse,ot as protectedResourceRequest,Dt as pushedAuthorizationRequest,Wt as refreshTokenGrantRequest,Bt as revocationRequest,z as skipAuthTimeCheck,Tt as skipStateCheck,ut as skipSubjectCheck,oe as useMtlsAlias,zt as userInfoRequest,Oe as validateAuthResponse,kt as validateDetachedSignatureResponse,Ht as validateIdTokenSignature,Pt as validateJwtAccessToken,Qt as validateJwtAuthResponse,Nt as validateJwtIntrospectionSignature,ht as validateJwtUserInfoSignature,hn as validateJwtUserinfoSignature};
